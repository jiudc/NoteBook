# 代理模式

**给目标对象提供一个代理对象，代理对象包含该目标对象，并控制对该目标对象的访问。**

- 通过代理对象的隔离，可以在对目标对象访问前后**增加额外的业务逻辑，实现功能增强。**
- 通过代理对象访问目标对象，可以**防止系统大量地直接对目标对象进行不正确地访问**，出现不可预测的后果

**如何实现代理模式**

- **定义真实对象和代理对象的公共接口**
- **代理对象内部保存对真实目标对象的引用**
- 访问者仅能通过代理对象访问真实目标对象，**不可直接访问目标对象**

## 一、静态代理

动态代理产生代理对象的时机是**运行时动态生成**，它没有 Java 源文件，**直接生成字节码文件实例化代理对象**；而静态代理的代理对象，在**程序编译时**已经写好 Java 文件了，直接 new 一个代理对象即可。

动态代理比静态代理更加稳健，对程序的可维护性和可扩展性更加友好

## 二、动态代理

**动态代理解决的问题是面对新的需求时，不需要修改代理对象的代码，只需要新增接口和真实对象，在客户端调用即可完成新的代理。**

### 2.1、JDK Proxy



### 2.2、CGLIB Prxoy

底层ASM字节码生成框架，FastClass

### 2.3、静态代理、JDK代理、CGLIB代理对比

| 处理方式      | 实现                                                                                                                                                            | 优点                             | 缺点                                      | 特点                            |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | --------------------------------------- |:-----------------------------:|
| JDK静态代理   | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口                                                                                                                                  | 实现简单，容易理解                      | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 | 好像没啥特点                        |
| JDK动态代理   | 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写`invoke`方法来进行动态代理的，在invoke方法中将对方法进行增强处理                                                                           | 不需要硬编码接口，代码复用率高                | 只能够代理实现了接口的委托类                          | 底层使用反射机制进行方法的调用               |
| CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过`super`调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了`MethodInterceptor`接口的对象，若存在则将调用intercept方法对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对`final`类以及final方法进行代理                | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 |
