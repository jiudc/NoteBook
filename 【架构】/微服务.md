# 一、微服务架构综述

## 1.1、架构发展史

单体架构、SOA、微服务

### 1.1.1、4S

safety、speed、scale、shading

### 1.1.2、单体架构面临的挑战

1. 维护成本增加

2. 交付周期长

3. 新人培养周期长

4. 技术更新成本高

## 1.2、微服务架构

### 1.2.1、定义（核心点）

1. 松耦合

2. 业务上下文独立

### 1.2.2、特点

1. 小——多小才算小

2. 独——独立的进程

3. 轻——轻量级通信机制

4. 松——松耦合的交付

### 1.2.3、本质

1. 以缩短交付周期为核心

2. 基于devops

3. 演进式架构

### 1.2.4、特征

1. 服务作为组件

2. 围绕业务来组建团队

3. 产品驱动而非项目驱动

4. 技术多样性

5. 业务数据独立

6. 基础设施自动化

### 1.2.5、需要考虑的因素

1. 分布式系统的复杂度
   
   1. 网络
   
   2. 性能
   
   3. 可靠性
   
   4. 异步
   
   5. 数据一致性
   
   6. 工具
   
   7. 安全

2. 运维成本

3. 组织架构

4. 服务间的集成测试

5. 服务治理

# 二、微服务生态系统

## 2.1、核心内容

1. 接入层：
   
   1. 原因：由于每个服务有独立的服务地址，可能面临升级成本高、传输效率低、协议一致性的挑战。
   
   2. 解决方案：可参考门面模式，引入接入层。
   
   3. 职责：
      
      1. 对客户隐藏多个微服务的访问地址
      
      2. 负责服务请求的路由及协议转换
      
      3. 实现公共职责，身份验证、权限控制、请求预处理

2. 业务层
   
   1. 服务拆分
      
      1. 业务功能
      
      2. 数据模型
      
      3. 限界上下文
   
   2. 服务实现：资源定义、业务逻辑、业务模型、模型存储、数据映射、网关集成
   
   3. 服务间通信：如何选择同步通信、异步通信机制，如何使用RPC、REST、消息队列
   
   4. 服务设计模式
   
   5. 数据一致性：ACID。（2PC、3PC、TCC、Sagas）

3. 支撑层
   
   1. 注册发现
   
   2. 负载均衡
   
   3. 配置管理
   
   4. 监控告警
   
   5. 日志聚合
   
   6. 调用链
   
   7. 容错

4. 基础设施：IaaS、PaaS、CaaS

## 2.2、工程实践

1. 交付流水线
   
   1. 提交
   
   2. 构建
   
   3. 验证
   
   4. 发布

2. 开发框架：演进阶段
   
   1. API为中心（Spring Boot）
   
   2. 初步支持服务治理（Spring Cloud、Dubbo、ServiceComb）
   
   3. 服务治理简化（Service Mesh）

3. 工程实践
   
   1. 服务开发
   
   2. 基础设施
   
   3. 部署管理
   
   4. 运维管理
   
   5. 交付流水线
   
   6. 服务的设计与实现
   
   7. 测试管理

# 三、微服务关键技术

## 3.1、服务设计

### 3.1.1、服务划分

**原则**：

1. 单一职责原则

2. 服务依赖原则

3. 服务自治原则

**划分策略**

1. 基于业务功能

2. 基于数据模型，也称作数据驱动方式的方式划分，是一种自底向上的实现方式。也要考虑访问机制（读密集、写密集）；读写性能

3. 限界上下文：通过建立统一语言、梳理业务流、识别事件和命令、最终寻找聚合和限界上下文

4. 基于非功能因素：
   
   1. 可复用性（通用服务）
   
   2. 资源使用（IO密集、计算密集）
   
   3. 交付频率（频繁发布抽离独立）
   
   4. 可伸缩性

**衡量合理性**

1. 服务能否独立交付

2. 服务所属团队规模

3. 是否破坏服务依赖原则

4. 是否满足单一职责原则

### 3.1.2、服务实现

**资源定义**

请求端与服务端交互时，服务端响应对业务模型的表现形式。包括表述内容与表述格式（XML、JSON）。

**业务逻辑**

**业务模型**

**存储模型**

**网关集成**

负责与其他系统协作，通过访问其他服务暴露的接口，获取数据或者提交数据。

### 3.1.3、服务间通信

**通信方式**

1. 同步
   
   1. RPC
      
      1. 对于开发人员，与本地调用一样，容易进行开发和设计
      
      2. 基于socket的二进制RPC协议，建立连接的延迟低，网络传输效率高
      
      3. RPC支持有状态的双向通信，实时性好
      
      4. 缺点是耦合高，RPC实现机制依赖特定语言和平台
   
   2. REST
      
      1. 资源
      
      2. 表述
      
      3. 状态转移：客户端能通过资源的表述，实现操作资源的目的
      
      4. 统一接口

2. 异步
   
   1. MQ
      
      1. 持久性
      
      2. 排队标准
      
      3. 安全策略
      
      4. 清理策略
      
      5. 处理通知
      
      6. 拉模式
      
      7. 推模式
      
      8. 优点：服务间解耦、异步通信、消息的持久化及恢复支持
      
      9. 缺点：实现复杂度增加、平台或者协议依赖、维护成本高
   
   2. 后台处理任务
      
      1. 任务
      
      2. 队列
      
      3. 定时器
      
      4. 执行器

### 3.1.4、服务设计模式

**链式模式**

按照数据流向进行服务拆分。

优点：实现简单直观

缺点：整个调用链采用同步机制通信，调用完成前消费者端会一直阻塞。当调用链路长时，会影响整体性能和稳定性，无法并行处理。

**聚合器模式**

当某个服务需要调用其他多个服务，进行业务功能组装时，便形成了聚合器模式。优点是能够清晰看到业务逻辑的组装，缺点是难以保证数据的唯一性。

如下场景适合聚合器模式：

1. 对业务集中处理

2. 服务间需要并发处理

如下场景不适合：

1. 不希望业务逻辑过度膨胀

**基于事件的异步模式**

服务间协作的关键点是消息。因此要保证消息发布与消息的状态保持一致。利于生成订单和发布订单生成事件，需要保持原子操作。

适用场景：

1. 用户体验有即时性要求，不希望被阻塞

2. 待处理任务比较独立，可同时运行

不适合场景：

1. 任务之间存在高度的顺序依赖关系

**事件溯源模式**

采用以事件为中心保存业务实体。每当业务实体的状态发生变化时，发布新事件到事件仓库中，系统可以通过回放来重新生成实体的当前状态。遵循的最终一致性。

由于每次发生的事件都做了持久化，因此采用事件溯源架构可以带来如下好处：

1. 准确的审计日志

2. 支持系统状态重建

适用场景：

1. 希望获得细粒度的审计日志

2. 希望记录所发生的事件并能通过重播事件来重建系统

不适用场景：

1. 数据强一致性的系统

**物化视图模式**

微服务架构中不同服务有各自的数据存储机制，这导致数据关联查询可能要经过多个服务，效率低。为了支持有效的关联查询，可通过提前生成视图的方式，将所需要的结果保存下来。当视图的源数据更改时，必须更新视图以同步信息。

适用场景：

1. 聚合服务需要从多个服务中请求数据时，在面临性能问题时，可提前创建物化视图

2. 数据库链接不稳定时，可以作为缓存使用

3. 出于安全或者隐私的原因，无法提供访问源数据的特定子集的访问权限时，可以创建物化视图将特定数据暴露为用户

不适用场景：

1. 源数据变化频繁，视图更新的开销较大

2. 对于一致性有较高要求的场景

**CQRS**

- 命令：对数据的更新

- 查询：对数据的获取

优势：

1. CQRS使用单独的查询和更新模型，能简化设计和实现，增强灵活性

2. 查询模型和更新模型可以访问不同的物理存储，能显著提高性能、可扩展性和安全性

适用场景：

1. 数据读取和写入的性能需要分开进行优化

2. 需要跨团队开发

3. 与其他系统集成，特别是与事件溯源相结合时，某个系统的临时故障不会影响其他系统的可用性

不适用场景：

1. 领域或业务规则简单

2. 简单的CRUD逻辑及相关数据访问操作

### 3.1.5、服务接入

**边缘服务**

简化外部消费者对系统的调用。可以是纯前端的页面，用于获取多个服务的数据后提供给消费者，也可以是聚合类服务，将结果进行聚合后返回给消费者。

**API网关**

- 请求路由

- 协议转换

- 公共功能：认证、鉴权、限流、流量统计

某些系统会将API网关作为聚合服务使用，不建议如此使用，因为

- 确保网关逻辑单一，聚焦于请求路由等功能

- 降低其替代成本

使用API网关，优势

1. 屏蔽服务接口的变化

2. 降低公共功能的维护成本

带来的问题：API网关是对外唯一入口，其发生故障将会导致整个系统不可用，API网关性能下降会导致所有服务的性能下降。

### 3.1.6、数据一致性

**分布式系统与数据一致性**

ACID（原子、一致、隔离、持久）

CAP(Consistency一致、可用Availability、分区容错Partition Tolerance)

**最终一致性及实现方式**

基于CAP理论，在无法实现强一致性的情况下，可以采用适当的方法达到最终一致性。于是出现BASE理论，即基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistency）

- 基本可用：在分布式系统出现故障时，允许系统的可用性下降或部分可用，系统提供熔断、降级功能

- 软状态：系统中的数据可以存在中间状态，可以容忍数据的同步延迟

- 最终一致性：系统在没有后续更新的前提下，返回上一次更新后的值，保证最终返回数据的一致性

最终一致性包括：

- 2PC两阶段提交：1）协调者单点；2）不能完全解决数据一致性，提交阶段网络阻塞等
  
  - 准备阶段：协调者查询所有参与者，确认是否准备好事务提交（将事务执行到准备提交的阶段）
  
  - 提交阶段：协调者通知参与者执行，每个参与者执行提交，释放事务占用的锁和资源，返回成功的确认
  
  - 若在准备阶段出错，协调者通过所有参与者回滚

- 3PC三阶段提交
  
  - 确认阶段：询问各服务是否可以执行事务
  
  - 预提交阶段：超时两端都取消
  
  - 提交阶段：协调者遇到超时会取消，参与者遇到超时会提交

- TCC尝试-确认-取消
  
  - Try：业务操作
  
  - Confirm/Cancel：确认/回滚，这一阶段应该是幂等

- Sagas补偿交易：由子事务的集合组成，每个子事务都具有事务补偿的功能。使用场景
  
  - 嵌套调用
  
  - 高并发
  
  - 调用时间长

### 3.1.7、身份认证及鉴权

- 分布式Session：引入缓存存储session

- 单点登录：Oauth2、SAML

- 无状态的Token：JWT

## 3.2、服务治理

### 3.2.1、注册发现

**WHY**：服务消费者和服务者需要网络地址才能通信。若发生变化需要手动维护。

- 手动注册实例地址的成本高

- 无法识别服务重启后网络地址的变化

**核心机制**

- 实例信息注册到注册中心

- 获取服务实例列表

- 与服务实现通信

**服务发现方式**

- 客户端发现

- 服务端发现：相较客户端发现，调用者的请求会直接发送到负载均衡器，由负载均衡器与注册中心交互

### 3.2.2、负载均衡

**实现**

- 服务端负载均衡：负载均衡器位于服务端，也称作集中式负载均衡（F5、HAProxy、Nginx、LVS）

- 客户端负载均衡：以库的形式集成到服务消费中。消费者和服务者是直接调用

- 策略：
  
  - 随机策略
  
  - 轮询策略
  
  - 权重策略
  
  - 响应时间策略
  
  - 另一类是基于会话保持：
    
    - 源地址hash
    
    - cookie识别
    
    - 基于session

### 3.2.3、配置管理

- 基础设施的连接信息

- 协作服务的地址信息

- 业务行为的配置参数

- 与特性相关的信息

**配置管理策略**

- 去中心化式的配置管理：git存储或以环境变量的形式注入服务启动的进程

- 集中式的配置管理：
  
  - 将配置放在配置中心
  
  - 通过配置中心更新配置
  
  - 各个服务从配置中心主动或被动地获取对配置的修改
  
  - 配置变更：服务实例拉取、配置中心向实例推送

### 3.2.4、容错机制

- 限流
  
  - 设置阈值
  
  - 服务降级
  
  - 通过优先级队列对负载进行分级来平滑流量
  
  - 延迟执行优先级较低的请求

- 超时与重试
  
  - 取消
  
  - 重试
  
  - 延迟后重试

- 雪崩：
  
  - 服务提供者不可用（自动扩容、限流）
  
  - 重试加大流量
  
  - 服务消费者不可用（降级）

- 隔离：资源隔离
  
  - 防止引发服务级联故障
  
  - 在发生服务故障时保留一些功能

- 熔断和回退
  
  - 关闭：默认情况下，断路器出于关闭状态，如果持续出错，失败计数器超过阈值，则进入打开状态
  
  - 打开：在指定时间段内，不再向服务提供者发送请求，而是直接回退到失败的结果，并启动超时计数器
  
  - 半开：计数器超时后，断路器进入半开，允许发送少量请求尝试，并且通过计数器计算成功请求数。若仍失败，则返回到打开状态，若计数超过阈值，则关闭。

## 3.3、服务运维

### 3.3.1、监控和告警

**监控策略**

- 数据收集

- 数据聚合

- 数据存储（TSDB，时间序列数据库）

- 数据展示

**监控指标**

- 资源监控

- 性能监控

- 业务监控

**告警机制与实现**

- 告警策略

- 告警分级

- 通知策略

- 消除策略

### 3.3.2、调用链跟踪

- 原理：Dapper将整个调用链看做跟踪树

- 可选方案：
  
  - Zipkin
  
  - Pinpoint
  
  - Jaeger
  
  - SkyWalking

### 3.3.3、日志聚合

ELK

- 服务间传递请求标识

- 设置唯一的服务标识符

- 利用工具进行日志收集

- 利用聚合工具进行聚合

# 四、微服务参考模型

## 4.1、为何需要参考模型

提供一套可落地、易实施的微服务实践指导

**从参考模型中收益**

- 尽早识别出微服务演进过程中的风险

- 有效制定实施过程中的阶段性目标

- 有助于自组织团队培养及积累最佳实践

- 打造团队专属的技术与工具图谱

## 4.2、参考模型的核心内容

### 4.2.1、适应性评估

**业务属性**

- 数据一致性

- 实时性

- 可用性

**竞争力**

- 交付周期

- 可伸缩性

### 4.2.2、成熟度评估

微服务过程划分为三个方向、八个维度、五个阶段。

- 团队与文化
  
  - 全功能团队
  
  - 敏捷实践

- 架构与技术
  
  - 服务设计与实现
  
  - 服务支撑组件
  
  - 运维管理

- 工程与实践：
  
  - 测试管理
  
  - 持续集成
  
  - 部署管理

五个阶段：

1. Stage0：初始阶段

2. Stage1：已管理阶段

3. Stage2：已定义阶段

4. Stage3：量化管理

5. Stage4：持续优化

### 4.2.3、度量指标

**结果类度量指标**

- 交付：周期时间

- 发布：部署频率

- 运维：故障恢复时间（MTTR）

- 质量：系统可用性

**过程类度量指标**

- 开发

- 持续集成

- 质量

- 环境

- 部署

- 组织

## 4.3、如何使用参考模型

1. 适用性评估：微服务架构本质、客观应对系统的差异性以及执行适用性评估
   
   1. 记录型系统，稳定准确，微服务不一定适用
   
   2. 差异化系统
   
   3. 创新型系统

2. 理清现状并定义目标
   
   1. 梳理价值流映射图
   
   2. 创建价值流映射图
      
      1. 确定价值流所需要的角色
      
      2. 梳理从需求开始，一直到交付给用户这个过程中所经历的所有活动
      
      3. 标记出每项活动的处理时间
   
   3. 识别现状，补齐短板
   
   4. 制定演进目标，确定度量项

3. 提升微服务交付能力
   
   1. 持续优化服务
   
   2. 完善支撑层、接入层和基础设施
   
   3. 提升微服务的交付能力

4. 持续演进
