# JVM

## 代码执行

1. .java->编译器->字节码文件
2. 字节码文件->JVM->机器码

- 编译为class：javac
- 装载class：ClassLoader
- 执行class
  - 解释执行
  - 编译执行：client compiler、server compiler

## 内存管理

### 内存空间

#### 方法区（永生代）

用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HostSpotVM把GC分代收集扩展至方法区，使用JAVA堆的永久代来实现方法区。永久代收集的主要目标是常量池的回收和类型的卸载。

- 线程共享
- 运行时常量池：是方法区的一部分，Class文件中除了有类型的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量和符号引用。
- 在JAVA8中，永久代已经被移除，被一个称为”元数据区“的区域所取代。元空间和永久代最大区别在于：元空间并不在虚拟机中，而是使用本地内存。类的元数据放在native memory，字符串池和类的静态变量放入java队中，这样加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

#### 堆（类实例区）-运行时数据区

被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收回最重要的内存区域。

- 新生代：用来存放新生的对象，一般占据对的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC
  - eden：Java新对象的出生地，若新创建的对象占用内存较大，则直接分配到老年代。当Eden区的内存不够的时候就会触发MinorGC
  - from survivor：上一次GC的幸存者
  - to survivor：保留已一个MinorGC过程的幸存者
  - MinorGC：采用复制算法（复制-》清空-》互换）
    - eden、servivorFrom区域中存活的对象复制的servivorTo区域，对象的年龄+1，若有对象年龄达到老年的标准或者ServivorTo区域不够位置，则赋值到老年代区
    - 清空eden、servivorFrom中的对象
    - ServivorTo和ServivorFrom互换
- 老年代：主要存放生命周期长的内存对象，比较稳定，所以Major不会频繁执行，在进行MajorGC之前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收。
  - MajorGC：采用标记清除算法，扫描一次所有的老年代，标记出存活对象，回收没有标记的对象。MajorGC的耗时较长，因为要扫描再回收。MajorGC会产生内存碎片，为减少内存损耗，一般需要进行合并或者标记出来方便下次直接分配。老年代满了装不下，即会爆出OOM异常。
- 异常：OutOfMemoryError

#### 虚拟机栈

- 线程私有
- 一个线程中，每调用一个方法创建一个栈帧
- 栈帧的结构：用于存储局部变量表、操作数栈、动态链接、方法出口等信息
  - 本地变量表local variable
  - 操作数栈operand stack
  - 对运行时常量池的引用
- 异常
  - StackOverflowError：线程请求的栈深度大于JVM所允许的深度
  - OutOfMermoryError：若JVM允许动态扩展，若无法申请到足够内存

#### 本地方法栈

与Java Stack类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native犯法服务

- 线程私有
- 异常
  - StackOverflowError
  - OutOfMemoryError

#### pc寄存器

- 线程私有
- 指向虚拟机字节码指令的位置
- 唯一一个无OOM的区域

### 内存分配

#### 堆上分配

#### TLAB分配

#### 栈上分配

### 内存回收

#### 如何确定垃圾

##### 引用计数法

一个对象如果没有任何与之关联的引用，即他们的引用计数为零，说明这个对象不太可能被再用到，那么这个对象就是可回收对象。

##### 可达性分析

为解决引用计数法的循环引用的问题，Java使用了可达性分析方法。通过一些列的”GC roots“对象作为起点搜索。若在”GC roots“和对象之间没有可达路径，则称该对象是不可达的。不可达对象不等价与可回收对象，不可达对象变成可回收对象至少经历两次标记过程。

#### 算法

##### Copy

按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这块存满后将尚存活的对象复制到另一块，将已使用的内存清理掉。

实现简单，内存效率高不易产生对象，缺点是可用内存被压缩为一半。

##### Mark-Sweep

- 标记-》清除
- 内存碎片化严重

##### Mark-Compact

- 标记后不是清理对象，而是将存活对象移向内存的一端
- 然后清理端边界外的对象

##### 分代收集

- 新生代采用Copying算法
- 老年代采用标记复制算法

##### 分区收集

将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。可以控制一次回收多少个空间，根据目标停顿时间，合理回收若干个小区间（而不是整个堆），从而减少一次GC所产生的停顿。

#### 四种引用

- 强引用：将一个对象赋给一个引用对象，它处于可达状态，不可能被垃圾回收机制回收的
- 软引用：SoftReference，当系统内存空间不足时它会被回收
- 弱引用：WeakReference，它比软引用的生存期更短，只要垃圾回收机制一运行，总会回收该对象占用的内存
- 虚引用：PhantomReference，不能单独使用，必须和引用队列联合使用。主要作用时跟踪对象被垃圾回收的状态。

#### 垃圾收集器

##### Serial垃圾收集器（单线程、复制算法）

最基本垃圾收集器，使用复制算法。在收集垃圾的过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾回收效率，依然时Java虚拟机运行在Client模式下默认的新生代垃圾收集器。

##### ParNew垃圾收集器（Serial+多线程）

Serial收集器的多线程版本，也使用复制算法。在垃圾收集过程中同样也要暂停所有其他的工作线程。

默认开启和CPU数目相同的线程数，可以通过-XX：ParallelGCThreads参数来限制垃圾收集器的线程数。

ParNew时很多java虚拟机运行在Server模式下的新生代的默认垃圾收集器。

##### Parallel Scavenge收集器（多线程复制算法、高效）

是一个新生代垃圾收集器，使用复制算法，重点关注的是程序达到一个可控制的吞吐量（运行用户代码时间/(运行用户代码时间+垃圾回收时间)），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序地运行任务，主要适用于在后台计算而不许看要太多交互地任务。自适应调节策略也是ParallelScavenge与ParNew地一个重要区别。

##### Serial Old垃圾收集器（单线程标记整理算法）

Serial的老年代版本，采用标记整理算法，Java虚拟机运行在Client模式下默认的老年代垃圾收集器。

##### Parallel Old收集器（多线程标记整理算法）

Parallel Scavenge的老年代版本

##### CMS收集器（多线程标记清除算法）

Concurrent Mark Sweep，主要目标是获得最短垃圾回收停顿时间，采用多线程标记清除算法

1. 初始标记：标记GC roots能关联到的对象，速度很快，仍然需要暂停所有线程
2. 并发标记：进行GC roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程
3. 重新标记：修正并发标记过程中，由于用户线程继续运行而导致产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程
4. 并发清除：清除GC roots不可达对象，和用户线程一起工作，不需要暂停工作线程

因为耗时最长的并发标记和并发清除是和用户线程一起工作，总体来看CMS收集器是和用户线程一起并发地执行。

##### G1收集器

Gabage First，与CMS相比由两点改进：

1. 基于标记整理，不产生碎片
2. 可非常精确控制停顿时间，在不牺牲吞吐量的情况下，实现低停顿垃圾回收

G1避免全区域垃圾回收，把内存划分为独立的区域，跟踪区域垃圾回收进度，在后台维护一个优先级列表，根据每次所允许的收集时间，优先收集垃圾最多的区域。区域划分和优先级区域回收机制，保证G1可以在有限时间获得最高的回收效率。

#### Sun JDK

##### 分代回收

##### GC参数

##### G1

### 内存状态分析

#### jconsole

#### visualvm

#### jstat

#### jmpa

#### MAT

## 线程资源同步和交互机制

### 线程资源同步

### 线程交互机制

### 线程状态及分析方法

# JAVA中四种引用

## 强引用



