# JVM

## 代码执行

1. .java->编译器->字节码文件
2. 字节码文件->JVM->机器码
- 编译为class：javac
- 装载class：ClassLoader
- 执行class
  - 解释执行
  - 编译执行：client compiler、server compiler

## 内存管理

### 内存空间

#### 方法区（永生代）

用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HostSpotVM把GC分代收集扩展至方法区，使用JAVA堆的永久代来实现方法区。永久代收集的主要目标是常量池的回收和类型的卸载。

- 线程共享
- 运行时常量池：是方法区的一部分，Class文件中除了有类型的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量和符号引用。
- 在JAVA8中，永久代已经被移除，被一个称为”元数据区“的区域所取代。元空间和永久代最大区别在于：元空间并不在虚拟机中，而是使用本地内存。类的元数据放在native memory，字符串池和类的静态变量放入java队中，这样加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

#### 堆（类实例区）-运行时数据区

被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收回最重要的内存区域。

- 新生代：用来存放新生的对象，一般占据对的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC
  - eden：Java新对象的出生地，若新创建的对象占用内存较大，则直接分配到老年代。当Eden区的内存不够的时候就会触发MinorGC
  - from survivor：上一次GC的幸存者
  - to survivor：保留已一个MinorGC过程的幸存者
  - MinorGC：采用复制算法（复制-》清空-》互换）
    - eden、servivorFrom区域中存活的对象复制的servivorTo区域，对象的年龄+1，若有对象年龄达到老年的标准或者ServivorTo区域不够位置，则赋值到老年代区
    - 清空eden、servivorFrom中的对象
    - ServivorTo和ServivorFrom互换
- 老年代：主要存放生命周期长的内存对象，比较稳定，所以Major不会频繁执行，在进行MajorGC之前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收。
  - MajorGC：采用标记清除算法，扫描一次所有的老年代，标记出存活对象，回收没有标记的对象。MajorGC的耗时较长，因为要扫描再回收。MajorGC会产生内存碎片，为减少内存损耗，一般需要进行合并或者标记出来方便下次直接分配。老年代满了装不下，即会爆出OOM异常。
- 异常：OutOfMemoryError

#### 虚拟机栈

- 线程私有
- 一个线程中，每调用一个方法创建一个栈帧
- 栈帧的结构：用于存储局部变量表、操作数栈、动态链接、方法出口等信息
  - 本地变量表local variable
  - 操作数栈operand stack
  - 对运行时常量池的引用
- 异常
  - StackOverflowError：线程请求的栈深度大于JVM所允许的深度
  - OutOfMermoryError：若JVM允许动态扩展，若无法申请到足够内存

#### 本地方法栈

与Java Stack类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native犯法服务

- 线程私有
- 异常
  - StackOverflowError
  - OutOfMemoryError

#### pc寄存器

- 线程私有
- 指向虚拟机字节码指令的位置
- 唯一一个无OOM的区域

### 内存分配

#### 堆上分配

#### TLAB分配

#### 栈上分配

### 内存回收

#### 如何确定垃圾

##### 引用计数法

一个对象如果没有任何与之关联的引用，即他们的引用计数为零，说明这个对象不太可能被再用到，那么这个对象就是可回收对象。

##### 可达性分析

为解决引用计数法的循环引用的问题，Java使用了可达性分析方法。通过一些列的”GC roots“对象作为起点搜索。若在”GC roots“和对象之间没有可达路径，则称该对象是不可达的。不可达对象不等价与可回收对象，不可达对象变成可回收对象至少经历两次标记过程。

#### 算法

##### Copy

按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这块存满后将尚存活的对象复制到另一块，将已使用的内存清理掉。

实现简单，内存效率高不易产生对象，缺点是可用内存被压缩为一半。

##### Mark-Sweep

- 标记-》清除
- 内存碎片化严重

##### Mark-Compact

- 标记后不是清理对象，而是将存活对象移向内存的一端
- 然后清理端边界外的对象

##### 分代收集

- 新生代采用Copying算法
- 老年代采用标记复制算法

##### 分区收集

将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。可以控制一次回收多少个空间，根据目标停顿时间，合理回收若干个小区间（而不是整个堆），从而减少一次GC所产生的停顿。

#### 四种引用

- 强引用：将一个对象赋给一个引用对象，它处于可达状态，不可能被垃圾回收机制回收的
- 软引用：SoftReference，当系统内存空间不足时它会被回收
- 弱引用：WeakReference，它比软引用的生存期更短，只要垃圾回收机制一运行，总会回收该对象占用的内存
- 虚引用：PhantomReference，不能单独使用，必须和引用队列联合使用。主要作用时跟踪对象被垃圾回收的状态。

#### 垃圾收集器

##### Serial垃圾收集器（单线程、复制算法）

最基本垃圾收集器，使用复制算法。在收集垃圾的过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾回收效率，依然时Java虚拟机运行在Client模式下默认的新生代垃圾收集器。

##### ParNew垃圾收集器（Serial+多线程）

Serial收集器的多线程版本，也使用复制算法。在垃圾收集过程中同样也要暂停所有其他的工作线程。

默认开启和CPU数目相同的线程数，可以通过-XX：ParallelGCThreads参数来限制垃圾收集器的线程数。

ParNew时很多java虚拟机运行在Server模式下的新生代的默认垃圾收集器。

##### Parallel Scavenge收集器（多线程复制算法、高效）

是一个新生代垃圾收集器，使用复制算法，重点关注的是程序达到一个可控制的吞吐量（运行用户代码时间/(运行用户代码时间+垃圾回收时间)），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序地运行任务，主要适用于在后台计算而不许看要太多交互地任务。自适应调节策略也是ParallelScavenge与ParNew地一个重要区别。

##### Serial Old垃圾收集器（单线程标记整理算法）

Serial的老年代版本，采用标记整理算法，Java虚拟机运行在Client模式下默认的老年代垃圾收集器。

##### Parallel Old收集器（多线程标记整理算法）

Parallel Scavenge的老年代版本

##### CMS收集器（多线程标记清除算法）

Concurrent Mark Sweep，主要目标是获得最短垃圾回收停顿时间，采用多线程标记清除算法

1. 初始标记：标记GC roots能关联到的对象，速度很快，仍然需要暂停所有线程
2. 并发标记：进行GC roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程
3. 重新标记：修正并发标记过程中，由于用户线程继续运行而导致产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程
4. 并发清除：清除GC roots不可达对象，和用户线程一起工作，不需要暂停工作线程

因为耗时最长的并发标记和并发清除是和用户线程一起工作，总体来看CMS收集器是和用户线程一起并发地执行。

##### G1收集器

Gabage First，与CMS相比由两点改进：

1. 基于标记整理，不产生碎片
2. 可非常精确控制停顿时间，在不牺牲吞吐量的情况下，实现低停顿垃圾回收

G1避免全区域垃圾回收，把内存划分为独立的区域，跟踪区域垃圾回收进度，在后台维护一个优先级列表，根据每次所允许的收集时间，优先收集垃圾最多的区域。区域划分和优先级区域回收机制，保证G1可以在有限时间获得最高的回收效率。

#### Sun JDK

##### 分代回收

##### GC参数

##### G1

### 内存状态分析

#### jconsole

#### visualvm

#### jstat

#### jmpa

#### MAT

## JAVA IO\NIO

### 阻塞IO模型

最传统的IO模型，即在读写数据时会发生阻塞。当用户发出IO请求时，内核会查询数据是否就绪，若没有就绪，则发生阻塞，用户线程交出CPU；若就绪则将数据拷贝到用户进程，并返回结果给用户进程，解除block状态。date=socket.read()是典型的阻塞案例

### 非阻塞IO模型

当用户发起IO请求时不阻塞，立刻返回。需要轮询内核数据是否准备好，不会交出CPU，会导致CPU占用率非常高。

### 多路复用IO模型

会有一个线程不断去轮询多个socket状态，只有socket真正有读数据时，才真正调用实际的IO读写操作。

多路复用为何比非阻塞效率高，因为多路复用轮询socket的状态时在内核态完成的而非阻塞IO是在用户态。

多路复用是轮询socket状态，并且逐一响应。若事件响应体大，就会导致后续的事件迟迟得不到响应，影响新的轮询。

### 信号驱动IO模型

当用户发起IO请求时，会给响应的socket注册一个信号函数，然后用户继续执行。当内核数据就绪时发送一个信号给用户线程，用户线程接收到这个信号后，在信号函数中调用IO操进行实际的IO操作。

### 异步IO模型

异步模型的时候，两步都不会阻塞线程，两步是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程不需要再调用IO进行操作。这点与信号驱动IO模型不同，在信号驱动中，用户接收到信号，表示数据已经就绪，然后用户线程调用IO操作；在异步IO模型中，收到信号表示IO操作已经完成。

### JAVA IO包

#### 字节流

##### InputStream

##### OutputStream

#### 字符流

##### Reader

##### Writer

### Java NIO

NIOJ基于Channel和Buffer继续操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道。

NIO和传统IO第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。

#### Channel

Channel和IO中的Stream是差不多，只不过Stream是单向的，而Channel是双向的

- FIleCHannel
- DatagramChannel
- SocketChannel
- ServerSocketChannel

#### Buffer

缓冲区，实际是一个容器，是一个连续数组。Buffer是一个顶层父类，它是一个抽象类，常见的Buffer子类有：ByteBuffer、IntBuffer、CHarBuffer、LongBuffer、DoubleBuffer、FloatBuffer

#### Selector

能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行响应的响应处理。单个线程可以监听多个数据通道。

## JVM类加载机制

### 加载

这个阶段在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。

- Class文件
- Zip包（jar包和war包）
- 计算
- 其他文件（JSP文件转换为对应的Class类）

### 验证

确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求。

### 准备

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

### 解析

解析阶段是指虚拟机将常量池的符号引用替换为直接引用的过程。

#### 符号引用

符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

1. CONSTANT_Class_info
2. CONSTANT_Field_info
3. CONSTANT_Method_info

#### 直接引用

直接引用可以是指向目标的指针，偏移量或者一个能直接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。

### 初始化

前面的类加载阶段之后，除了在加载阶段可以自定义加载器以外，其他操作都由JVM主导。到初始阶段，才真正执行类中定义的Java程序代码。

#### 类构造器<client>

初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>（）方法

以下几种情况不会执行类初始化：

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的
2. 定义对象数组
3. 常量在编译器间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类
4. 通过类名获取Class对象
5. 同故宫CLass.forName加载指定类时，如果制定参数initialize为false时，也不会触发类初始化
6. 通过ClassLoader默认的loadClass方法

### 类加载器

虚拟机设计团队把加载动作放到JVM外部实现，一边让应用程序决定如何获取所需的类，JVM提供了三种类加载器：

#### 启动类加载器（Bootstrap ClassLoader）

负载加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定目镜中

#### 扩展类加载器（Extension ClassLoader）

负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量制定路径中类库

#### 应用程序类加载器（Application ClassLoader）

负责加载用户路径(classpath)上的类库

JAVM通过双亲委派模型进行类的加载，我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器

自定义加载器=》应用程序类加载器=》扩展类加载器=》启动类加载器

### 双亲委派

当一个类收到了类加载亲贵，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类完成。只有当父类加载器反馈自己无法完成这个请求（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。可以保证使用不同的类加载器最终得到的都是同样的一个对象。

### OSGI（动态模型系统）

Open Service Gataway Initiative，是面向Java的动态模型系统，是Java动态化模块系统的一系列规范。

#### 动态改变构造

OSGI服务平台提供在多种网络设备上无需重启的动态改造构造的功能。

#### 模块化编程和热插拔

OSGi旨在为实现Java程序的模块化编程提供基础条件，基于OSGi的程序很可能可有实现模块级的热插拔功能，当程序升级时，可以只停用、重新安装然后重启程序的其中一部分。

## 线程资源同步和交互机制

### 线程资源同步

### 线程交互机制

### 线程状态及分析方法

# JAVA集合

## LIST

### ArrayList

内部通过数组实现，它允许对元素进行快速随机访问。数据的缺点是每个元素之间不能由间隔，当数组大小不满足是需要增加存储能力，就要将已经由数据的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除数据时·，需要对数据进行复制、移动，代价比较高。它适合随机查找和遍历，不适合插入和删除。

### Vector

与ArrayList一样，通过数组实现，不同的是它支持线程的同步，访问速度比ArrayList慢

### LinkList

用链表结构存储数据，很适合数据的动态插入和删除。随机访问和遍历速度较慢。

## Set

值不能重复。

### HashSet

哈希表存放的是哈希值。HashSEt存储元素的顺序并不是按照存入是的顺序。元素的哈希值通过hashcode()方法来获取，HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果返回为true，HashSet视为同一个元素。

哈希值相同equals为false的元素在同样的哈希值下顺延（哈希桶）。

### TreeSet

1. TreeSet()使用二叉树的原理对新add的对象按照制定的顺序拍寻，每增加一个对象都会进行排序，将对象插入二叉树指定的位置
2. Integer和String对象都可以继续默认的TreeSet排序，而自定的对象必须实现Comparable接口
3. 在覆写compare()函数时，要返回相应的值，小于、等于或大于，分别返回负整数、零或正整数

### LinkHashSet（HashSet+LinkedHashMap）

LinkHashSet底层使用LinkedHashMap来保存所有元素。

## Map

### HashMap（数组+链表+红黑树）

HashMap根据hashCode值存储数据。最多只允许一条记录的键为null。HashMap非线程安全。

### ConcurrentHashMap

#### Segment段

ConcurrentHashMap和HashMap思路差不多，支持并发。整个ConcurrentHashMap由一个个Segment组成，Segment代表部分或者一段，又称分段锁或者槽。

#### 线程安全（继承ReentrantLock加载）

ConcurrentHashMap是一个Segment数组，Segment通过继承ReentrantLock进行加载，所以每次需要加载的操作锁住一个segment，这样只要保证每个segment是线程安全的，就实现了全局的线程安全。

#### 并行度（默认16）

ConcurrentHashMap有16个segments，所以理论上，最多支持16个线程并发写。这个值在初始化可以设置为其他值，一旦初始化以后，他是不可以扩容的。

### HashTable（线程安全）

遗留类，与HashMap类似，线程安全，并发性不如ConcurrentHashMap。不建议在新代码中使用，不需要线程安全可以用HashMap替换，需要线程安全可以用ConcurrentHashMap替换。

### TreeMap（可排序）

TreeMap实现SortedMap接口，按照键值排序（默认升序）。当用Iterator遍历TreeMap时，得到的记录时排过序的。

使用TreeMap时，key必须实现Comparable接口，或者在构造TreeMap传入自定义的Comparator

### LinkedHashMap（记录插入顺序）

是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历时，先得到的记录时先插入的。

# Java多线程并发

## Java创建线程

### 继承Thread类

Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程唯一的方法就是通过Thread类的start()实例方法。start()是一个native方法。

### 实现Runnable接口

### ExecutorService、Callable<Class>、Future

有返回值的任务必须实现Callable接口。执行Callable任务后，可以获取一个Future对象，在该对象上调用get就可以获取Callable任务返回的Object了。

## 线程池

Java线程池的顶级接口时Executor，严格意义上Executor并不是一个线程池，而只是一个执行线程的工具。真正线程池的接口时ExecutorService。

### newCachedThreadPool

创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时重用他们。

调用executor将重用以前构造的线程，如果现有的线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除哪些已有60秒钟未被使用的线程。长时间保持空闲的线程池不会使用任何资源。

### newFixedThreadPool

创建一个可重用的固定线程数的线程池，以共享的无界队列方式来运行这些线程。

### newScheduledThreadPool

创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。

### newSingleThreadExecutor

Executors.newSingleThreadExecutor()返回一个线程池（只有一个线程），这个线程可以在线程死后重新启动一个线程代替原来地线程继续执行。

## 线程的生命周期

### 新建状态（NEW）

当程序使用new创建一个线程后，该线程处于新建状态，仅由JVM为其分配内存，并初始化其成员变量的值

### 就绪状态（RUNNABLE）

调用start()方法之后，该线程就处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

### 运行状态（RUNNING）

如果处于就绪状态的线程获得CPU，开始执行run()方法的线程执行体

### 阻塞状态（BlOCKED）

#### 等待阻塞

运行的线程中执行o.wait()方法，JVM会把该线程放入等待队列

#### 同步阻塞

运行的线程获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中

#### 其他阻塞

运行的线程执行Thread.sleep(long ms)或t.join()，或者发出了IO请求，JVM会把该线程置为阻塞状态。

当sleep状态超时、join等待线程终止或者超时、IO处理完毕，线程重新转入可运行状态

### 线程死亡

#### 正常结束

run()或call()方法执行完成，线程正常结束

#### 异常结束

线程抛出一个未捕获的Exception或Error

#### 调用stop

直接调用线程的stop方法来结束该线程，容易导致死锁。

## 线程终止方式

### 正常运行结束

程序运行结束

### 使用退出标志退出线程

一般run()方法执行完，线程就会正常结束，而有些线程是四幅线程。他们需要长时间的运行，自由在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，最直接就是设置一个boolean，通过这个标志来控制while是否退出循环。

### Interrupt方法结束线程

#### 线程处于阻塞

当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态。一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。

#### 线程未处于阻塞状态

使用isInterrupted()判断线程的终端标志来退出循环。当使用interrupt方法时，中断标志就会置true

### stop方法终止线程（线程不安全）

thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。加载的代码是为了保证数据的一致性，若突然释放（不可控制），那么被保护的数据就可能出现不一致性，其他线程在使用这些被破环的数据时，可能会出现奇怪的应用程序错误。

## sleep和wait区别

1. sleep属于Thread，而wait属于Object类
2. sleep导致线程暂停执行指定的时间，让出cpu，但监控状态依然保持着
3. 调用sleep线程不会释放对象锁
4. wait线程会放弃对象锁，进入等待此对象的等待锁定池

## start和run区别

1. start()方法来启动线程，真正实现了多线程运行。无需等待run方法体代码执行完毕，可以直接继续执行下面的代码
2. 通过调用Thread类的start()方法来启动一个线程，此时线程处于就绪状态
3. run()称为线程体，包含了要执行这个线程的内容，线程就进入了运行状态。

## JAVA后台线程

1. 守护线程，也称服务进程，为用户线程提供公共服务，在没有用户线程可服务时会自动离开
2. 优先级：守护线程的优先级比较低
3. 通过setDaemon(true)来设置守护线程
4. 在Daemon线程中产生的新线程也是Daemon的
5. 线程时JVM级别的
6. 垃圾回收线程就是一个典型的守护进程，当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开
7. 生命周期：它独立于控制终端并且周期性地执行某种任务或者等待处理某些发生地事件。当JVM中所有的线程都是守护进程的时候，JVM就可以退出了。

## JAVA锁

### 乐观锁

乐观锁是一种思想，认为读多写少，遇到并发写的概率较低，每次去拿数据都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有人去更新这个数据。采取在写时先读出当前的版本号，然后枷锁操作（比较跟上一次的版本号，如果一样就更新），如果失败则要重复读-比较-写操作

Java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，并比较当前值跟传入值是否一样，一样就更新，否则失败

### 悲观锁

任务写多，遇到并发概率较高，每次读数据就会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到才转换为悲观锁，如ReentrantLock

### 自旋锁

如果持有锁的线程能够在很短时间内释放资源，那么那些等待竞争锁的线程就不需要做内核态和用户态的切换进入阻塞挂起状态，他们只需要等一等（自旋），等持有锁的线程释放资源后即可立即获取锁，避免用户线程和内核切换的消耗

线程自选需要消耗cpu，需要设定一个自选等待的最大时间。若持有锁的线程超过自旋等待最大时间仍然没有释放锁，争用线程会停止自旋进入阻塞状态。

#### 自旋锁的优缺点

 自旋锁对于锁竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度提升，因为自旋的消耗会小于线程阻塞挂起在唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换。

如果锁竞争激烈或者持有锁的线程长时间占用锁执行同步块，这时候就不适合使用自旋锁。

#### 自旋锁时间阈值

在1.6引入适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上自旋时间以及锁的拥有者的状态来决定。基本认为一个线程上下文切换的时间是最佳的一个时间。

### Synchronized同步锁

属于独占式的悲观锁，同时属于可重入锁。

1. 作用于方法时，锁着的是对象的实例（this）
2. 作用于静态方法时，锁着的是Class实例，由因为Class数据存储在永久代中，是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程
3. synchronized作用一个对象实例时，锁住的时所有以对象为锁的代码块。

#### Synchronized核心组件

1. Wait Set：那些调用wait方法被阻塞的线程
2. Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中
3. Entry List：Contention List中那些由资格成为候选资源的线程被移动到Entry List中
4. OnDeck：任意时刻，最多只有一个线程正在竞争锁资源
5. Owner：当前已经获取到锁资源的线程称为Owner
6. ！Owner：当前释放锁的线程

#### Synchronized实现

##### monitorenter

1. 如果monitor进入数为0，则线程进入monitor，进入数设置为1，线程为monitor的所有者
2. 如果线程已经占有monitor，则进入数据+1
3. 若其他线程已经占用，则线程进入阻塞

##### monitorexit

执行monitorexit的进程必须时monitor的所有者

指令执行时，monitor进入数减1，如果减1进入数为0，那么线程退出monitor

##### 锁竞争过程

1. JVM每次从WaitingQueue的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下ContentionList会被大量并发的线程进行CAS访问，为减低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程
2. Owner线程会在unlock时，将ContentionList的部分线程迁移到EntryList，并指定EntryList作为候选竞争线程
3. Owner线程并不直接把锁传递为OnDeck线程，而是把竞争的权力交给OnDeck，与自旋等竞争
4. OnDeck获取锁进程就会变为Owner线程，而没有得到所资源仍然停留在EntryList中
5. 若Owner线程被wait方法阻塞，则转移到WaitSet中，直到某个时刻通过notify或notifyAll唤醒，会重新进入EntryList
6. Synchronize是非公平锁。Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，获取不到就进入ContentionList，这明显对于已经进入队列的线程时不公平的，还有自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源
7. 每个对象都有一个monitor对象，加锁就是在竞争monitor对象
8. synchronized时一个重量级操作，需要调用操作系统相关接口，性能时低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多
9. Java1.6对synchronized进行了很多优化，适应自旋、锁消除、锁粗化、轻量级锁及偏向锁。
10. 锁可以从偏向锁升级到轻量级锁，在升级到重量级锁，这种升级过程叫做锁膨胀
11. JDK1.6默认开启偏向锁和轻量级锁，可通过-XX：-UseBiasedLocking来禁用偏向锁

### ReentrantLock

ReentrantLock继承接口Lock，时一种可重入锁，除了能完成synchronized所能完成的所有工作外，还提供了可响应中断锁、可轮询锁请求、定时锁等避免多线程锁死的方法

#### Lock接口主要方法

1. void lock()：执行此方法时，如果锁处于空闲状态，当前那线程将获取到锁。如果锁已经被其他线程， 将禁用当前线程，知道当前线程获取到锁
2. boolean tryLock()：如果锁可用，则获取锁，并立即返回true，否则false
3. void unlock():当前线程将释放持有的锁，锁只能由持有者释放，否则可能导致异常
4. Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁半丁，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁
5. getHoldCount():查询当前线程保持此锁的次数， 也就是执行lock的次数
6. getQueueLength():返回正等待获取此锁的线程估计数
7. getWaitQueueLenght：返回等待与此锁相关条件的线程估计数
8. hasWaiters：